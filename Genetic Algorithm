#inputfile taken as "input_layouts.txt" file
import random, math, os

#prb
Block_Comp = {
    "ALU": (5, 5),
    "Cache": (7, 4),
    "Control Unit": (4, 4),
    "Register File": (6, 6),
    "Decoder": (5, 3),
    "Floating Unit": (5, 5),
}
BLOCK_NYMS = list(Block_Comp.keys())
WIRE_CNNCTION=[(3, 0), (2, 0), (0, 1), (3, 5), (1, 4), (4, 5)]
CHIP_WIDTH, CHIP_HEIGHT = 25, 25
alpha, beta, gamma = 1000, 2, 1


# utility
def is_overlap(ax, ay, aw, ah, bx, by, bw, bh):
    return not (ax + aw <= bx or ax >= bx + bw or ay + ah <= by or ay >= by + bh)

def fitness(chromo):
    overlaps = 0
    wire_len = 0.0
    for i in range(len(chromo)):
        for j in range(i + 1, len(chromo)):
            x1, y1 = chromo[i]
            x2, y2 = chromo[j]
            w1, h1 = Block_Comp[BLOCK_NYMS[i]]
            w2, h2 = Block_Comp[BLOCK_NYMS[j]]
            if is_overlap(x1, y1, w1, h1, x2, y2, w2, h2):
                overlaps += 1

    for i, j in WIRE_CNNCTION:
        x1, y1 = chromo[i]
        x2, y2 = chromo[j]
        w1, h1 = Block_Comp[BLOCK_NYMS[i]]
        w2, h2 = Block_Comp[BLOCK_NYMS[j]]
        cx1, cy1 = x1 + w1 / 2, y1 + h1 / 2
        cx2, cy2 = x2 + w2 / 2, y2 + h2 / 2
        wire_len += math.hypot(cx1 - cx2, cy1 - cy2)

    x_min = min(x for x, y in chromo)
    y_min = min(y for x, y in chromo)
    x_max = max(x + Block_Comp[BLOCK_NYMS[i]][0] for i, (x, y) in enumerate(chromo))
    y_max = max(y + Block_Comp[BLOCK_NYMS[i]][1] for i, (x, y) in enumerate(chromo))
    area = (x_max - x_min) * (y_max - y_min)

    f = - (alpha * overlaps + beta * wire_len + gamma * area)
    return f, overlaps, wire_len, area

def generate_random():
    chromo = []
    for name in BLOCK_NYMS:
        w, h = Block_Comp[name]
        x = random.randint(0, CHIP_WIDTH - w)
        y = random.randint(0, CHIP_HEIGHT - h)
        chromo.append((x, y))
    return chromo

# IO
def load_input(filename):
    pop = []
    if not os.path.isfile(filename):
        return pop
    with open(filename) as f:
        for line in f:
            coords = line.strip().split("),")
            chromo = []
            for coord_str in coords:
                coord_str = coord_str.replace("(", "").replace(")", "")
                parts = coord_str.strip().split(",")
                if len(parts) == 2:
                    try:
                        x = int(parts[0].strip())
                        y = int(parts[1].strip())
                        chromo.append((x, y))
                    except ValueError:
                        continue
            if len(chromo) == 6:
                pop.append(chromo)
    return pop

def write_output(result, filename="best_task01.txt"):
    layout = result['layout']
    with open(filename, 'w') as f:
        f.write(f"Best Fitness: {result['fitness']:.2f}\n")
        f.write(f"Overlaps: {result['overlaps']}\n")
        f.write(f"Wiring: {result['wire']:.2f}\n")
        f.write(f"Bounding Box Area: {result['area']:.2f}\n")
        f.write("Layout:\n")
        for name, (x, y) in zip(BLOCK_NYMS, layout):
            f.write(f"{name}: ({x},{y})\n")

# Gen_ops
def flatten(chromo): return sum(chromo, ())
def rebuild(flat): return [(flat[i], flat[i+1]) for i in range(0, len(flat), 2)]

def crossover(p1, p2):
    g1 = flatten(p1)
    g2 = flatten(p2)
    point = random.randint(1, len(g1) - 1)
    return [rebuild(g1[:point] + g2[point:]), rebuild(g2[:point] + g1[point:])]

def mutate(chromo, rate=0.1):
    new_chromo = chromo.copy()
    if random.random() < rate:
        i = random.randint(0, 5)
        w, h = Block_Comp[BLOCK_NYMS[i]]
        x = random.randint(0, CHIP_WIDTH - w)
        y = random.randint(0, CHIP_HEIGHT - h)
        new_chromo[i] = (x, y)
    return new_chromo

def roulette_select(pop, scores):
    total = sum(scores)
    probs = [s / total for s in scores]
    return random.choices(pop, weights=probs, k=2)

# GA_loops
def run_genetic(max_gen=15, pop_size=6, patience=5, input_file=None):
    pop = load_input(input_file)
    if not pop:
        print("No valid input found. Generating random population.")
        pop = [generate_random() for _ in range(pop_size)]

    best_f = float('-inf')
    best = None
    stagnant = 0

    for gen in range(max_gen):
        evals = [(fitness(p), p) for p in pop]
        evals.sort(reverse=True, key=lambda x: x[0][0])
        if evals[0][0][0] > best_f:
            best_f = evals[0][0][0]
            best = evals[0]
            stagnant = 0
        else:
            stagnant += 1

        print(f"Gen {gen+1}: Best Fitness = {evals[0][0][0]:.2f}, Overlaps = {evals[0][0][1]}")

        if stagnant >= patience:
            print(" Early stopping: No improvement for", patience, "generations.")
            break

        elites = [evals[i][1] for i in range(min(2, len(evals)))]
        next_pop = elites.copy()

        scores = [fitness(p)[0] for p in pop]

        while len(next_pop) < pop_size:
            p1, p2 = roulette_select(pop, scores)
            c1, c2 = crossover(p1, p2)
            next_pop.append(mutate(c1))
            if len(next_pop) < pop_size:
                next_pop.append(mutate(c2))

        pop = next_pop

    f, o, w, a = best[0]
    return {'fitness': f, 'overlaps': o, 'wire': w, 'area': a, 'layout': best[1]}

if __name__ == '__main__':
  # Sir, here I've covered both output on the console and in a textfile
    result = run_genetic(input_file="input_layouts.txt")
    write_output(result)
    print("\n==== Best Result Found ====")
    print(f"Best Fitness: {result['fitness']:.2f}")
    print(f"Overlaps: {result['overlaps']}")
    print(f"Wiring: {result['wire']:.2f}")
    print(f"Bounding Box Area: {result['area']:.2f}")
    print("Layout:")
    for name, (x, y) in zip(BLOCK_NYMS, result['layout']):
        print(f"{name}: ({x},{y})")

    print("\n Task 01 output also saved to best_task01.txt")


#_________________________________________________________________________________________________NEXT TASK___________________________________________________________________________________________________


import random
import math

#prb

Block_Comp = {
    "ALU": (5, 5),
    "Cache": (7, 4),
    "Control Unit": (4, 4),
    "Register File": (6, 6),
    "Decoder": (5, 3),
    "Floating Unit": (5, 5)
}

BLOCK_NAMES = list(Block_Comp.keys())
NUM_BLOCKS = len(BLOCK_NAMES)

WIRE_CNNCTION = [
    (3, 0), (2, 0), (0, 1), (3, 5), (1, 4), (4, 5)
]

CHIP_WIDTH, CHIP_HEIGHT = 25, 25
alpha, beta, gamma = 1000, 2, 1

#fitness

def is_overlap(ax, ay, aw, ah, bx, by, bw, bh):
    return not (
        ax + aw <= bx or ax >= bx + bw or
        ay + ah <= by or ay >= by + bh
    )

def calculate_fitness(chromo):
    overlaps = 0
    wire_length = 0.0

    for i in range(NUM_BLOCKS):
        for j in range(i + 1, NUM_BLOCKS):
            x1, y1 = chromo[i]
            x2, y2 = chromo[j]
            w1, h1 = Block_Comp[BLOCK_NAMES[i]]
            w2, h2 = Block_Comp[BLOCK_NAMES[j]]
            if is_overlap(x1, y1, w1, h1, x2, y2, w2, h2):
                overlaps += 1

    for i, j in WIRE_CNNCTION:
        x1, y1 = chromo[i]
        x2, y2 = chromo[j]
        w1, h1 = Block_Comp[BLOCK_NAMES[i]]
        w2, h2 = Block_Comp[BLOCK_NAMES[j]]
        cx1, cy1 = x1 + w1 / 2, y1 + h1 / 2
        cx2, cy2 = x2 + w2 / 2, y2 + h2 / 2
        wire_length += math.hypot(cx1 - cx2, cy1 - cy2)

    x_min = min(x for x, y in chromo)
    y_min = min(y for x, y in chromo)
    x_max = max(x + Block_Comp[BLOCK_NAMES[i]][0] for i, (x, y) in enumerate(chromo))
    y_max = max(y + Block_Comp[BLOCK_NAMES[i]][1] for i, (x, y) in enumerate(chromo))
    area = (x_max - x_min) * (y_max - y_min)

    fitness = - (alpha * overlaps + beta * wire_length + gamma * area)
    return fitness, overlaps, wire_length, area

#I/O

def load_input_file(filename):
    pop = []
    with open(filename) as f:
        for line in f:
            chromo = []
            coords = line.strip().replace("),", "):").split("):")
            for c in coords:
                if c:
                    try:
                        parts = c.replace("(", "").replace(")", "").split(",")
                        x, y = int(parts[0].strip()), int(parts[1].strip())
                        chromo.append((x, y))
                    except:
                        print(f"Skipping invalid: {c}")
            if len(chromo) == NUM_BLOCKS:
                pop.append(chromo)
    return pop

def write_output(result, filename="best_task02.txt"):
    fitness, overlaps, wire, area = result['fitness'], result['overlaps'], result['wire'], result['area']
    layout = result['layout']
    with open(filename, 'w') as f:
        f.write(f"Best Fitness: {fitness:.2f}\n")
        f.write(f"Overlaps: {overlaps}\n")
        f.write(f"Wiring Distance: {wire:.2f}\n")
        f.write(f"Bounding Area: {area:.2f}\n")
        f.write("Layout:\n")
        for name, (x, y) in zip(BLOCK_NAMES, layout):
            f.write(f"{name}: ({x}, {y})\n")

# Gen_oprtrs

def generate_random_chromosome():
    chromo = []
    for block in BLOCK_NAMES:
        w, h = Block_Comp[block]
        x = random.randint(0, CHIP_WIDTH - w)
        y = random.randint(0, CHIP_HEIGHT - h)
        chromo.append((x, y))
    return chromo

def reconstruct(genome):
    return [(genome[i], genome[i + 1]) for i in range(0, len(genome), 2)]

def two_point_crossover(p1, p2):
    g1 = sum(p1, ())
    g2 = sum(p2, ())
    idx1 = random.randint(0, len(g1) - 2)
    idx2 = random.randint(idx1 + 1, len(g1) - 1)
    c1 = g1[:idx1] + g2[idx1:idx2] + g1[idx2:]
    c2 = g2[:idx1] + g1[idx1:idx2] + g2[idx2:]
    return [reconstruct(c1), reconstruct(c2)]

def mutate(chromo, mutation_rate=0.1):
    if random.random() < mutation_rate:
        idx = random.randint(0, NUM_BLOCKS - 1)
        w, h = Block_Comp[BLOCK_NAMES[idx]]
        x = random.randint(0, CHIP_WIDTH - w)
        y = random.randint(0, CHIP_HEIGHT - h)
        chromo[idx] = (x, y)
    return chromo

# Gen-Al

def genetic_algorithm(generations=15, pop_size=6, input_file=None):
    if input_file:
        population = load_input_file(input_file)
    else:
        population = [generate_random_chromosome() for _ in range(pop_size)]

    best_fit = float('-inf')
    best = None

    for g in range(generations):
        scored = [(calculate_fitness(chromo), chromo) for chromo in population]
        scored.sort(reverse=True, key=lambda x: x[0][0])

        if scored[0][0][0] > best_fit:
            best_fit = scored[0][0][0]
            best = scored[0]

        new_population = [scored[0][1]]
        while len(new_population) < pop_size:
            p1 = random.choice(population)
            p2 = random.choice(population)
            children = two_point_crossover(p1, p2)
            for child in children:
                mutate(child)
                new_population.append(child)
                if len(new_population) >= pop_size:
                    break
        population = new_population

    fitness, overlaps, wire, area = best[0]
    layout = best[1]
    return {
        'fitness': fitness,
        'overlaps': overlaps,
        'wire': wire,
        'area': area,
        'layout': layout
    }


if __name__ == '__main__':
   # Sir, here I've covered both output on the console and in a textfile
    result = genetic_algorithm(input_file="input_layouts.txt")
    write_output(result)

    print(" Task 02 output saved to best_task02.txt")
    print(f"Best Fitness: {result['fitness']:.2f}")
    print(f"Overlaps: {result['overlaps']}")
    print(f"Wiring Distance: {result['wire']:.2f}")
    print(f"Bounding Area: {result['area']:.2f}")
    print("Layout:")
    for name, (x, y) in zip(BLOCK_NYMS, result['layout']):
        print(f"{name}: ({x}, {y})")
